Title: Software Engineering Processes and the BSCoE SEP
Published: 8/29/2006
Tags:
    - Legacy Blog
---
In addition to the technical assets that I’ve mentioned in previous blog postings, BSCoE also makes a set of software process assets available. These software process assets are arranged into disciplines and collected under the umbrella of BSCoE’s Software Engineering Process (SEP). Information about the BSCoE SEP is available online to the general public.

![BSCoE SEP Wheel](http://s3.beckshome.com/20060829-BSCoE-SEP-Wheel.jpg)

The SEP is based roughly upon the Rational Unified Process (RUP) and Microsoft Solutions Framework (MSF). Those looking at the sample assets will notice the similarities with the standard RUP templates. The process component of the SEP is specifically vague, leaving decisions such as formality versus agility, process activities, and roles to the projects employing the SEP. In particular, projects have several options for SEP customization including document-driven (RUP-style development case), local modifications to the process, or modifications with intent to contribute back changes to BSCoE for inclusion in the master SEP distribution. The SEP is conceptually similar in some ways to Ivar Jacobson’s new Essential Unified Process (EssUP). However, whereas the EssUP variability comes through the selection of practices, SEP’s variability comes through the selection of artifacts.

For those of you thinking of creating your own software processes, I can only recommend the experience. Using the RUP and the Rational Method Composer or the MSF and the new Team System templates, although educational, is not an easy process. This is especially true if you intend to employ lightweight, agile processes on your projects. In this case, modifying the base processes from the RUP or MSF is tantamount to carving a chess piece from a sculpture sized block of marble.

Fortunately, as always, there are many that have gone before us in this endeavor. The sources highlighted below were of great help to us in the creation of our process and are highly recommended whether you require guidance or are just looking to better understand software engineering processes in general:

* <b>Scott Ambler’s Writings</b> – This guy is truly the best place to start when you’re looking for anything process related. All roads will eventually lead through his work. Particularly interesting are Scott’s [Agile Unified Process](http://www.ambysoft.com/unifiedprocess/agileUP.html) and his [Enterprise Unified Process](http://www.enterpriseunifiedprocess.com/). The former is a lightweight version of the RUP focusing on test driven development, agile modeling, agile database techniques, and refactoring. The latter is an extension to the RUP covering enterprise disciplines not mentioned in conjunction with many software processes such as portfolio management, enterprise architecture, strategic reuse, and software process improvement. In addition, it adds two new phases to the RUP, production and retirement.
* <b>Philippe Kruchten’s Books</b> – The two Addison-Wesley Professional books <i>Rational Unified Process Made Easy</i> and <i>Rational Unified Process: An Introduction</i> are seminal works on the RUP. Often overlooked is <i>Software Engineering Processes: With the UPEDU</i>, a book that runs through an educational version of the Unified Process with some pretty decent explanations and online examples.
* <b>Craig Larman’s Books</b> – Craig’s books, although not focused on process engineering or the intricacies of processes, convey an awful lot of information in real world contexts. <i>Agile and Iterative Development: A Manager’s Guide</i> is one of the best ways for non-techie types to get their arms around lower ceremony development processes. <i>Applying UML and Patterns</i> focuses on modeling and design patterns but does so in the context of a process using the Unified Process infused with Agile methods, making it a source of great contextual information.

In addition, we have been picking up reference artifacts along the way to illustrate best practices and real world examples. One of the artifacts that I fell in love with was the <i>Yummy SAD</i>, available online as HTML and [downloadable in document format](http://download.boulder.ibm.com/ibmdl/pub/software/dw/library/rational/docs/YummySAD.doc) via HTTP. This is one of the most generic, understandable, and widely-applicable examples of a software architecture document (SAD) that I have come across. One of the big selling points of the Yummy SAD is that aside from just being an artifact, it also comes with an approach to architectural decomposition. In particular, it espouses an architecturally significant use case / quality attributes based approach to documenting and realizing your architecture. Explaining software architecture in this fashion has helped me clarify the relevance and importance of the SAD on more than one occasion.

Please feel free to share any best practice artifact references or software process tips that you might help accumulated over the years in the comments section below.